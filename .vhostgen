#!/usr/bin/perl
package VHostGen;
# @todo Улучшить обработку параметров командной строки

=pod

=encoding utf8

=head1 NAME

vhostgen - Утилита автоматической генерации конфига виртуальных хостов Apache
по существующей структуре директорий

=head1 SYNOPSIS

.vhostgen [<directory>]

=head1 DESCRIPTION

Утилита и главный конфиг F<.vhost.cfg> кладутся в директорию C<DocumentRoot>.
Дерево вложенных папок будет просканировано и обработано согласно конфигам.
В субдиректории по мере необходимости кладутся конфиги F<.vhost> с нужными
директивами. Глубина анализа субдиректорий при необходимости контролируется
конфигами. C<VirtualHost> создаётся только для самых вложенных из
проанализированных субдиректорий.

=head1 CONFIGURATION

Настройка утилиты отсуществляется с помощью двух типов конфигурационных файлов:

=over

=item F<.vhost.cfg> - Главный конфиг

Располагается в рабочей директории утилиты.

=item F<.vhost> - Конфиг директории

Располагается в анализируемых субдиректориях I<при необходимости>.

=back

Конфигурационный файл представляет собой текстовый файл с директивами.

B<Комментарии> начинаются с символа C<#> в начале строки (пробельные символы
впереди игнорируются). Комментарий может занимать только всю
строку целиком.

B<Директивы> имеют два способа указания значения:

=over

=item * Простое однострочное значение.

=item * Многострочное значение.

=back

=head1 AUTHOR

Copyright (С) 2009-2011 Vovan-VE <vovan-ve@yandex.ru>

=cut

use strict;
use Carp;
#use Data::Dumper;
use Cwd ();

use constant {
	VERSION_NAME   => 'VHostGen',
	VERSION_NUMBER => '3.0.2',
};
use constant {
	VERSION            => VERSION_NAME . '/' . VERSION_NUMBER,
	CONFIGURATION_FILE => '.vhost.cfg',
	CONFIG_DIR_FILE    => '.vhost',
};

# config variables bit flags
use constant {
	# source: 0xF: 1,2,4,8
	VAR_SOURCE => 0xF,
	VAR_SOURCE_PREDEF  => 0x0,
	VAR_SOURCE_GLOBAL  => 0x1,
	VAR_SOURCE_PERDIR  => 0x2,
	VAR_SOURCE_DYNAMIC => 0x4,

	# scope: 0x10: inheritable (default) or local per directory
	VAR_SCOPE => 0x10,
	VAR_SCOPE_INHERIT => 0x00,
	VAR_SCOPE_LOCAL   => 0x10,

	# type: 0x20: plaintext (default) or template
	VAR_TYPE => 0x20,
	VAR_TYPE_PLAINTEXT => 0x00,
	VAR_TYPE_TEMPLATE  => 0x20,

	# empty: 0x40: empty value means undefined value (default) or defined empty value
	VAR_EMPTY => 0x40,
	VAR_EMPTY_UNDEF => 0x00,
	VAR_EMPTY_VALUE => 0x40,

	# data: 0x80: scalar (default) or array (space separated list)
	VAR_DATA => 0x80,
	VAR_DATA_SCALAR => 0x00,
	VAR_DATA_ARRAY  => 0x80,

	# tpl: 0x100: if allowed to use in template
	VAR_TPL => 0x100,
	VAR_TPL_DENY  => 0x000,
	VAR_TPL_ALLOW => 0x100,
};
# @todo int value type

# config variable names with bitwise properties
my %configVarName = (
	time        => VAR_SOURCE_PREDEF | VAR_TPL_ALLOW,
	cwd         => VAR_SOURCE_PREDEF | VAR_TPL_ALLOW,
	version     => VAR_SOURCE_PREDEF | VAR_TPL_ALLOW,

	apacheconf  => VAR_SOURCE_GLOBAL,
	winhosts    => VAR_SOURCE_GLOBAL,
	winhostsip  => VAR_SOURCE_GLOBAL,
	port        => VAR_SOURCE_GLOBAL | VAR_SOURCE_PERDIR | VAR_TPL_ALLOW,
	depth       => VAR_SOURCE_GLOBAL | VAR_SOURCE_PERDIR | VAR_SOURCE_DYNAMIC,
	beginfile   => VAR_SOURCE_GLOBAL | VAR_TYPE_TEMPLATE,
	virtualhost => VAR_SOURCE_GLOBAL | VAR_TYPE_TEMPLATE,

	skip           => VAR_SOURCE_PERDIR | VAR_SCOPE_LOCAL | VAR_EMPTY_VALUE,
	name           => VAR_SOURCE_PERDIR | VAR_SCOPE_LOCAL,
	diralias       => VAR_SOURCE_PERDIR | VAR_SCOPE_LOCAL | VAR_DATA_ARRAY,
	domainalias    => VAR_SOURCE_PERDIR | VAR_TYPE_TEMPLATE | VAR_DATA_ARRAY,
	headers        => VAR_SOURCE_PERDIR | VAR_TYPE_TEMPLATE,
	headersreplace => VAR_SOURCE_PERDIR | VAR_SCOPE_LOCAL | VAR_EMPTY_VALUE,

	dirs       => VAR_SOURCE_DYNAMIC | VAR_DATA_ARRAY,
	aliases    => VAR_SOURCE_DYNAMIC | VAR_DATA_ARRAY,

	path       => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	subpath    => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	dir0       => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	domain     => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	domain0    => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	alias      => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
	extheaders => VAR_SOURCE_DYNAMIC | VAR_TPL_ALLOW,
);
# @todo префикс local перед директивой для переопределения локальности наследуемых директив (local port 80 | .port 80)
# @todo вставлять в шаблон часть массива (но в указанном порядке, да еще через такой-то разделитель). domain[1..5] , domain[5..1] , domain[1..>] , domain[<..5] , domain[5..<] , domain[>..1]

my ($cwd);
# default config values
my $config = {
	cwd         => undef,
	time        => undef,
	version     => VERSION,
	apacheconf  => './vhosts.conf',
	winhosts    => undef,
	winhostsip  => '127.0.0.1',
	port        => undef,
	depth       => 2,
	beginfile   => undef,
	virtualhost => undef,
};

{ package VHostGen::Template::Item;
	sub new($$) { }
	sub isvar($) { }
	sub isset($) { }
	sub get($) { }
	1;
}

{ package VHostGen::Template::Text;
	use base ('VHostGen::Template::Item');
	use Carp;

	sub new($$) {
		my ($self, $text) = @_;

		my $class = ref($self) || $self;
		bless \$text, $class;
	}

	sub isvar($) { 0; }

	sub isset($) { 1; }

	sub get($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->get()";
		my $v = $$self;
		(defined $v) ? $v : '';
	}

	1;
}

{ package VHostGen::Template::Var;
	use base ('VHostGen::Template::Item');
	use Carp;

	our %constant = (
		''   => '',
		'('  => '{',
		')'  => '}',
		'()' => '{}',
		'['  => '[',
		']'  => ']',
		'[]' => '[]',
	);

	our %allowed = map {
		($configVarName{$_} & VHostGen::VAR_TPL) == VHostGen::VAR_TPL_ALLOW
			? ($_ => 1)
			: ()
		;
	} keys %configVarName;

	sub new($$) {
		my ($self, $name) = @_;

		my $class = ref($self) || $self;
		$name = lc($name);
		return VHostGen::Template::Text->new($constant{$name})
			if exists $constant{$name};

		my $name0 = $name;
		$name0 =~ s/\d+$/0/;
		die "Unknown or disallowed variable \"$name\"\n"
			unless exists $allowed{$name0};

		bless \$name, $class;
	}

	sub isvar($) { 1; }

	sub isset($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->isset()";
		defined $config->{$$self};
	}

	sub get($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->get()";
		my $value = $config->{$$self};
		return '' unless defined $value;

		my $ref = ref $value;
		return $value unless $ref;

		return join(
			' ',
			map {
				( ref($_) && $_->isa('VHostGen::Template::Item') )
					? $_->get()
					: $_
			} @{$value}
		)
			if $ref eq 'ARRAY';

		$value;
	}

	1;
}

{ package VHostGen::Template::Cond;
	use base ('VHostGen::Template::Item');
	use Carp;

	sub new($\@) {
		my ($obj, $items) = @_;

		my $class = ref($obj) || $obj;
		my $self = {
			items => $items,
			vars  => [],
		};
		for my $item (@{$self->{items}}) {
			ref($item) && $item->isa('VHostGen::Template::Item')
				or croak "All array items must be an instance of VHostGen::Template::Item class";

			push @{$self->{vars}}, $item
				if $item->isvar();
		}
		return VHostGen::Template::Text->new(join '', map {$_->get()} @{$self->{items}})
			unless @{$self->{vars}};

		bless $self, $class;
	}

	sub isvar($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->isvar()";
		scalar @{$self->{vars}};
	}

	sub isset($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->isset()";
		return 1 unless @{$self->{vars}};
		for my $var (@{$self->{vars}}) {
			return 1 if $var->isset();
		}
		0;
	}

	sub get($) {
		my ($self) = @_;

		ref($self) or croak "usage: \$obj->get()";
		join( '', map { $_->isset() ? $_->get() : () } @{$self->{items}} );
	}

	1;
}

{ package VHostGen::Template;
	use base ('VHostGen::Template::Cond');

	sub new($$$) {
		my ($self, $code, $LinesBefore) = @_;

		my $class   = ref($self) || $self;
		my $items   = [];
		my $lastPos = 0;
		my @itemsStack;

		eval {
			# template  :: (<text> | <var> | <cond>)*
			# text      :: [^\[\]{}]+
			# var       :: \{[^{}]+\}
			# cond      :: \[<template>\]

			pos($code) = 0;
			while ($code =~ /(?<text>[^\[\]{}]+)|\{(?<var>[^{}]*)\}|(?<cond>[\[\]])|(?<err>.)/sg)
			{
				$lastPos = $-[0];
				my ($text, $var, $cond, $err) = @+{ qw(text var cond err) };
				die "Invalid character '$err'\n"
					if defined $err;

				# cond "[" or "]"
				if (defined $cond) {
					# [
					if ($cond eq '[') {
						push @itemsStack, $items;
						$items = [];
					}
					# ]
					else {
						die "Unexpected ']' without opening '['\n"
							unless @itemsStack;

						my $cond_item;
						$cond_item = VHostGen::Template::Cond->new($items)
							if @$items;

						$items = pop @itemsStack;
						push @$items, $cond_item
							if $cond_item;
					}
				}
				# variable {var}
				elsif (defined $var) {
					die "Unable to use template variable \"$var\" directly in template\n"
						if exists $configVarName{$var}
							&& VHostGen::VAR_TYPE_TEMPLATE == ($configVarName{$var} & VHostGen::VAR_TYPE)
					;

					push @$items, VHostGen::Template::Var->new($var);
				}
				# plain text
				else {
					push @$items, VHostGen::Template::Text->new($text);
				}
			}
		};
		if ($@) {
			chomp $@;
			my $start = substr($code, 0, $lastPos);
			my $line = 1 + ($start =~ tr/\n/\n/);
			die "Template error: $@ at line " . ($LinesBefore + $line) . " (inner line $line, inner offset: $lastPos)\n";
		}

		die "Template error: Expected ']' " . scalar(@itemsStack) . " times to close all unclosed '[' at the end\n"
			if @itemsStack;

		$class->SUPER::new($items);
	}

	sub newEmpty($) {
		my ($self) = @_;

		my $class = ref($self) || $self;
		$class->SUPER::new([]);
	}

	sub isvar($) { 0; }

	sub isset($) { 1; }

	1;
}


{ my (%loaded_configs);
	sub loadConfig($) {
		my ($filename) = @_;

		my $config = {};

		if (-e $filename) {
			my $data;
			{
				local $/;
				open(my $h, '<', $filename)
					or die "Unable to read configuration file $filename\n";

				$data = <$h>;
				close $h;
			}
			# replace CRLF and CR with LF
			$data =~ s/\r\n?/\n/g;

			pos($data) = 0;
			my $line = 1;
			while ($data =~ /
					# start of line
					^
					# skip leading horizontal spaces
					\h*
					# optional one of:
					(?:
						# comment
						\#.*
					|
						# option name
						(?<name>
							[a-z_][a-z_0-9]*
						)
						# optional with:
						(?:
							# horizantal spaces
							\h+
							# one of:
							(?:
								# open multiline marker with new line
								(?<ml>
									<<<<\n
								)
								# optional content:
								(?:
									# multiline value
									(?<mlv>
										# one line inside
										(?:
											# optional new line from previous line
											\n?
											# line start
											^
											# no close-marker here
											(?!
												>>>>$
											)
											# line content
											.*+
										)*+
									)
									# new line before close-marker
									\n
								)??
								# close marker
								>>>>$
							|
								# simple inline value
								(?<iv> .* )
							)
						)?
					|
						# invalid something else
						(?<invalid> .+ )
					)?
					# end of line
					$
				/gmxi)
			{
				my ($name, $multiline, $multiline_value, $inline_value, $invalid) =
					@+{ qw(name ml mlv iv invalid) };

				die "Unknown character '" . substr($invalid, 0, 1) . "' at line $line\n"
					if defined $invalid;

				if (defined $name) {
					my ($name_lower, $value, $start_line) = (lc $name, '', $line);
					my $name_lower_zero = $name_lower;
					$name_lower_zero =~ s/\d+$/0/;
					exists $configVarName{$name_lower_zero}
						or die "Unknown option '$name' at line $start_line\n";

					if (defined $inline_value) {
						# inline value
						($value = $inline_value) =~ s/\h+$//;
					}
					elsif (defined $multiline) {
						# multiline value
						$line++;
						if (defined $multiline_value) {
							$value = $multiline_value;
							$line += 1 + ($value =~ tr/\n/\n/);
						}
					}
					# no value specified: empty or undef
					( $value eq '' && VAR_EMPTY_UNDEF == ($configVarName{$name_lower_zero} & VAR_EMPTY) )
						and $value = undef;

					if (VAR_DATA_ARRAY == ($configVarName{$name_lower_zero} & VAR_DATA)) {
						my $new_value;
						if (defined $value) {
							$value =~ s/^\s+|\s+$//g;
							if ($value ne '') {
								$new_value = [ split(/\s+/, $value) ];
								if (VAR_TYPE_TEMPLATE == ($configVarName{$name_lower_zero} & VAR_TYPE)) {
									for my $word (@$new_value) {
										eval {
											$word = VHostGen::Template->new($word, $start_line);
										};
										if ($@) {
											chomp $@;
											die "Error in value of option $name on line $start_line: $@\n";
										}
									}
								}
							}
						}
						$value = $new_value || [];
					}
					else {
						if (defined $value) {
							if (VAR_TYPE_TEMPLATE == ($configVarName{$name_lower_zero} & VAR_TYPE)) {
								eval {
									$value = VHostGen::Template->new($value, $start_line);
								};
								if ($@) {
									chomp $@;
									die "Error in value of option $name on line $start_line: $@\n";
								}
							}
						}
					}
					$config->{$name_lower} = $value;
				}
				$line++;
			}

			return $config;
		}
		else {
			return;
		}
	}

	sub getConfig($) {
		my ($filename) = @_;
		exists $loaded_configs{$filename}
			or $loaded_configs{$filename} = loadConfig($filename);

		$loaded_configs{$filename};
	}
}

sub applyConfig(\%\%$) {
	my ($target, $data, $source) = @_;

	$source &= VAR_SOURCE;

	for my $name (keys $data) {
		($configVarName{$name} & $source)
			or die "Option '$name' is not allowed in this file\n";

		$target->{$name} = $data->{$name};
	}

	$target->{$_} = VHostGen::Template->newEmpty()
		for grep {
			($configVarName{$_} & $source)
			&& VAR_DATA_SCALAR   == ($configVarName{$_} & VAR_DATA)
			&& VAR_TYPE_TEMPLATE == ($configVarName{$_} & VAR_TYPE)
			&& ! defined $target->{$_}
		} keys %configVarName;

	1;
}

sub readConfig ($\%$) {
	my ($filename, $config, $source) = @_;

	my $read_config = getConfig($filename) || {};
	applyConfig(%$config, %$read_config, $source);

	1;
}

{ my $ApacheFH;
	sub ApacheConfOpen () {
		die "No value specified for ApacheConf\n"
			unless defined $config->{apacheconf};

		open $ApacheFH, ">", $config->{apacheconf}
			or die "Unable to open ApacheConf file \"$config->{apacheconf}\"\n";

		print $ApacheFH $config->{beginfile}->get();
		1;
	}

	sub ApacheConfVHost () {
		print $ApacheFH "\n", $config->{virtualhost}->get();
		1;
	}
}

{ my $WinHostsFH;
	sub WinHostsOpen() {
		return unless defined $config->{winhosts};
		die "WinHostsIP has no value when WinHosts is specified\n"
			unless defined $config->{winhostsip};

		open $WinHostsFH, ">", $config->{winhosts}
			or die "Unable to open WinHosts file \"$config->{winhosts}\"\n";

		print $WinHostsFH "# This file has been generated automatically by $config->{version} at $config->{time}\n\n";
		1;
	}

	sub WinHostsAdd() {
		return unless $WinHostsFH;
		print $WinHostsFH "$config->{winhostsip}\t\t$config->{domain}\n";
		1;
	}
}

sub usage() {
	my $ver = VERSION;
	die qq($ver
Usage: vhostgen [<directory>]

  <directory>
    Base working directory. By default current working directory will be used.
);

}

sub init () {
	# autoflush on
	$| = 1;
	my $oldfh = select STDERR;
	$| = 1;
	select $oldfh;

	my $argc = scalar @ARGV;
	if (0 == $argc) {
		$cwd = Cwd::cwd();
	}
	elsif (1 == $argc) {
		my $arg = $ARGV[0];
		if ($arg eq "-h" || $arg eq "-?" || $arg eq "--help") {
			usage();
		}
		elsif (-d $arg) {
			$cwd = Cwd::abs_path($arg);
		}
		else {
			usage();
		}
	}
	else {
		usage();
	}

	print VERSION, "\n";

	chdir $cwd or die "Unable to change working directory to $cwd\n";
	print "cwd is $cwd\n";

	$config->{cwd}  = $cwd;
	$config->{cwd}  =~ tr{\\}{/};
	$config->{path} = $config->{cwd};
	$config->{subpath} = '';

	{
		my ($s, $i, $h, $d, $m, $y) = localtime;
		$config->{time} = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $y + 1900, $m + 1, $d, $h, $i, $s);
	}

	for (grep { VAR_SOURCE_PREDEF == ($configVarName{$_} & VAR_SOURCE) } keys %configVarName)
	{
		$VHostGen::Template::Var::constant{$_} = $config->{$_};
	}

	my $cfg = './' . CONFIGURATION_FILE;
	eval {
		readConfig($cfg, %$config, VAR_SOURCE_GLOBAL);
	};
	die "Config \"$cfg\": $@\n"
		if $@;

	ApacheConfOpen();
	WinHostsOpen();
	print "\n";
	1;
}

{ my @configStack;
	sub configPush () {
		# бекапим ссылку на исходный конфиг
		push @configStack, $config;
		# новая ссылка на новый пустой конфиг
		my $copy = {};
		# копируем поштучно
		for my $name (keys %$config) {
			# кроме локальных
			next if VAR_SCOPE_LOCAL == ($configVarName{$name} & VAR_SCOPE);
			$copy->{$name} = $config->{$name};
		}
		# подменяем ссылку
		$config = $copy;
		1;
	}

	sub configPop () {
		croak "Config stack already empty"
			unless @configStack;

		$config = pop @configStack;
	}
}

sub enumDirs ($) {
	my ($path) = @_;

	return unless wantarray;
	opendir my $dir, $path
		or die "Unable to read the directory.\n";

	my @dirs = grep { $_ ne '.' && $_ ne '..' && -d $path . '/' . $_ } readdir $dir;
	closedir $dir;
	@dirs;
}

sub isValidDomainLabel($$) {
	my ($label, $level) = @_;
	return $level
		? $label =~ /^[a-z\d](?:[-a-z\d]*[a-z\d])?$/
		: $label =~ /^[a-z](?:[-a-z\d]*[a-z\d])?$/;
}

{ my (@subpath, @domains, @names, @namesCounts);
	my (%hosts, @host_index);

	sub aliases() {
		my $names_count = scalar @names;
		my $last_name_index = $names_count - 1;
		my @index = (0) x $names_count;
		my (@aliases, %domain_aliases, %bak);
		my $domain_alias_index = 0;
		my $total_count = 1;
		$total_count *= $namesCounts[$_] for 0 .. $last_name_index;

		if (defined $config->{domainalias}) {
			for my $i (0 .. $last_name_index) {
				my $n = 'domain' . $i;
				$bak{$n} = $config->{$n};
			}
			$bak{domain} = $config->{domain};
		}
		for my $total_index (0 .. $total_count - 1) {
			if (defined $config->{domainalias}) {
				push @aliases, $config->{domain} = join(
					'.',
					map {
						$config->{'domain' . $_} = $names[$_]->[$index[$_]]
					} reverse 0 .. $last_name_index
				);
				my $n = 0;
				for my $domain_alias ( map { $_->get() } @{$config->{domainalias}} ) {
					next if exists $domain_aliases{$domain_alias};
					$domain_aliases{$domain_alias} = {
						alias => $domain_alias,
						index => ++$n,
						id    => ++$domain_alias_index,
					};
				}
			}
			else {
				push @aliases, join(
					'.',
					map {
						$names[$_]->[$index[$_]]
					} reverse 0 .. $last_name_index
				);
			}
			my $c = 1;
			for my $n (reverse 0 .. $last_name_index) {
				$index[$n] += $c;
				last if $index[$n] < $namesCounts[$n];
				$c = int( $index[$n] / $namesCounts[$n] );
				$index[$n] %= $namesCounts[$n]
			}
		}

		if (defined $config->{domainalias}) {
			# убираем из %domain_aliases всё, что уже есть в @aliases
			delete $domain_aliases{$_} for @aliases;

			# добавляем %domain_aliases в @aliases
			push @aliases, map { $_->{alias} }
				sort {
					$a->{index} <=> $b->{index}
					or $a->{id} <=> $b->{id}
				}
				values %domain_aliases;

			for my $i (0 .. $last_name_index) {
				my $n = 'domain' . $i;
				$config->{$n} = $bak{$n};
			}
			$config->{domain} = $bak{domain};
		}

		$config->{aliases} = \@aliases;
		1;
	}

	sub vhostDir() {
		my $path = $config->{path};
		$hosts{$path} = $config;
		push @host_index, $path;
	}

	sub domainDir();
	sub domainDir() {
		my @dirs = enumDirs('.' . $config->{subpath});
		# отсортировать без учета регистра. преобразование Шварца
		@dirs = map  { $_->[1] }
				sort { $a->[0] cmp $b->[0] }
				map  { [lc($_), $_] }
				@dirs;
		for my $dir (@dirs) {
			configPush();
			$config->{depth}--;

			push @subpath, $dir;
			my $level = $#subpath;
			$config->{'dir' . $level} = $dir;
			$config->{dirs} = [ @subpath ];
			$config->{subpath} = '/' . join('/', @subpath);
			$config->{path}    = Cwd::abs_path( $config->{cwd} . $config->{subpath} );

			my $cfg = $config->{path} . '/' .  CONFIG_DIR_FILE;
			eval {
				readConfig($cfg, %$config, VAR_SOURCE_PERDIR);
			};
			warn "Config \"$cfg\" ignored: $@\n"
				if $@;

			TRY: {
				last if defined $config->{skip};
				my $domain = \(
					$config->{'domain' . $level} = lc(
						(defined $config->{name})
							? $config->{name}
							: $config->{dirs}->[$level]
					)
				);
				unless (isValidDomainLabel($$domain, $level)) {
					warn "Invalid domain \"$$domain\" in \"$config->{path}\" ignored.\n";
					last;
				}
				push @domains, $$domain;

				my @dir_aliases = ($$domain, (defined $config->{diralias}) ? @{$config->{diralias}} : ());
				push @names, \@dir_aliases;
				push @namesCounts, scalar @dir_aliases;

				if ($config->{depth} > 0) {
					domainDir();
				}
				else {
					aliases();
					vhostDir();
				}

				pop @namesCounts;
				pop @names;
				pop @domains;
			}

			pop @subpath;
			configPop();
		}
		1;
	}

	sub generateVhosts() {
		my $bak = $config;
		for my $path (@host_index) {
			$config = $hosts{$path};

			$config->{extheaders} = ( $config->{headers}->isset() )
				? $config->{headers}->get()
				: undef
			;

			my @aliases = @{ $config->{aliases} };
			# first item will be the main domain name
			# exclude it from aliases
			$config->{domain} = shift @aliases;

			$config->{alias} = (@aliases)
				? join(' ', @aliases)
				: undef
			;

			ApacheConfVHost();
			WinHostsAdd();

			print "[+] $config->{domain}\t $config->{path}\n";
		}
		$config = $bak;

		if (@host_index) {
			print "\n" . scalar(@host_index). " virtual hosts created\n";
		}
		else {
			print "No virtual hosts created\n";
		}
	}
}

init();
domainDir();
generateVhosts();
1;
